{"version":3,"sources":["ts/chain-part.ts","ts/chain-game.ts","ts/main.ts"],"names":[],"mappings":";AAiLC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAhLY,QAAA,UAAY,GAUzB,IAAA,EAAA,WA8BI,SAAA,EACY,EACA,GADA,KAAA,EAAA,EACA,KAAA,EAAA,EApBJ,KAAA,aAAc,EAQd,KAAA,UAAY,IAAI,IAcf,KAAA,OA0Hb,OA7II,OAAA,eAAI,EAAA,UAAA,aAAU,CAAd,IAAA,WACW,OAAA,KAAK,aADF,YAAA,EAuJjB,cAAA,IA/HG,EAAA,UAAA,KAAA,WAES,KAAA,SAAW,KAAK,MAAsB,EAAhB,KAAK,UAC3B,KAAA,MAAQ,KAAK,GAAK,EAAI,KAAK,SAC3B,KAAA,aAAc,EACd,KAAA,cAAgB,GAKzB,EAAA,UAAA,eAAA,SAAe,EAAsB,GAE5B,KAAA,UAAU,IAAI,EAAW,IAKlC,EAAA,UAAA,OAAA,WAEQ,KAAK,cAGJ,KAAA,aAAc,EACd,KAAA,cAAgB,EAChB,KAAA,cAKD,EAAA,UAAA,UAAR,WAEU,IAAA,EAAM,IAAI,eAAe,EAAU,UACzC,EAAI,KAAO,OACX,EAAI,UAAU,MAAQ,IAAsB,IAAhB,KAAK,SACjC,EAAI,QAAQ,EAAU,UACtB,EAAI,QACJ,WAAW,WAAM,OAAA,EAAI,QAAQ,MAKzB,EAAA,UAAA,gBAAR,WAAA,IAAA,EAAA,KAES,KAAA,UAAU,QAAQ,SAAC,EAAM,IAGJ,QAAd,GACmB,IAAlB,EAAK,UAAoC,IAAlB,EAAK,UACV,IAAlB,EAAK,UAAoC,IAAlB,EAAK,YAGf,UAAd,GACmB,IAAlB,EAAK,UAAoC,IAAlB,EAAK,UACV,IAAlB,EAAK,UAAoC,IAAlB,EAAK,YAGf,WAAd,GACmB,IAAlB,EAAK,UAAoC,IAAlB,EAAK,UACV,IAAlB,EAAK,UAAoC,IAAlB,EAAK,YAGf,SAAd,GACmB,IAAlB,EAAK,UAAoC,IAAlB,EAAK,UACV,IAAlB,EAAK,UAAoC,IAAlB,EAAK,YAGjC,EAAK,SACa,QAAd,GAAqC,SAAd,GACvB,EAAK,aAQrB,EAAA,UAAA,OAAA,WAEQ,KAAK,cACA,KAAA,OAAS,KAAK,MAAQ,KAAK,GAAK,KAAiB,EAAV,KAAK,IACrB,MAAtB,KAAK,gBACF,KAAA,aAAc,EACd,KAAA,UAAY,KAAK,SAAW,GAAK,EACjC,KAAA,qBAOjB,EAAA,UAAA,KAAA,SAAK,GAEK,IAAA,EAAW,QAAA,UAAY,EAC7B,EAAI,OACJ,EAAI,UAAY,OAChB,EAAI,YACkB,IAAlB,KAAK,SAAiB,OACJ,IAAlB,KAAK,SAAiB,MACJ,IAAlB,KAAK,SAAiB,QACtB,SACJ,EAAI,UAAY,EAChB,EAAI,UAAU,KAAK,EAAI,EAAU,KAAK,EAAI,GAC1C,EAAI,OAAO,KAAK,OACZ,KAAK,aACL,EAAI,YACJ,EAAI,IAAI,EAAG,EAAG,EAAU,EAAa,EAAV,KAAK,IAChC,EAAI,QAER,EAAI,YACJ,EAAI,OAAO,GAAI,GACf,EAAI,OAAO,EAAG,GACd,EAAI,OAAO,EAAU,GACrB,EAAI,SACJ,EAAI,WAIZ,EA5JA,GAAa,QAAA,UAAA,EAiKT,EAAU,SAAW,IAAI,aACzB,EAAU,SAAW,EAAU,SAAS,aACxC,EAAU,SAAS,KAAK,MAAQ,IAChC,EAAU,SAAS,QAAQ,EAAU,SAAS;;ACrKrC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAVb,IAAA,EAAA,QAAA,gBAGM,EAAa,GAGb,EAAc,EAAA,UAAY,EAIhC,EAAA,WAeI,SAAA,EACY,GAAA,KAAA,OAAA,EAEH,KAAA,QAAU,EAAO,WAAW,MAC5B,KAAA,WAAa,EAAO,wBAgGjC,OA3FI,EAAA,UAAA,MAAA,WAES,KAAA,OAAO,MAAQ,KAAK,OAAO,OAAS,EAEpC,KAAA,OAAO,iBAAiB,YAAa,KAAK,QAAQ,KAAK,OAEvD,KAAA,MAAQ,MAAM,KAAK,MAAM,GAAa,SAAC,EAAG,GAC3C,OAAA,MAAM,KAAK,MAAM,GAAa,SAAC,EAAG,GAC9B,OAAA,IAAI,EAAA,UAAU,EAAI,EAAA,UAAW,EAAI,EAAA,eAIpC,IAAA,IAAI,EAAI,EAAG,EAAI,EAAY,IACvB,IAAA,IAAI,EAAI,EAAG,EAAI,EAAY,IAAK,CAC3B,IAAA,EAAO,KAAK,MAAM,GAAG,GACvB,EAAI,GACJ,EAAK,eAAe,MAAO,KAAK,MAAM,EAAI,GAAG,IAE7C,EAAI,EAAa,GACjB,EAAK,eAAe,QAAS,KAAK,MAAM,GAAG,EAAI,IAE/C,EAAI,EAAa,GACjB,EAAK,eAAe,SAAU,KAAK,MAAM,EAAI,GAAG,IAEhD,EAAI,GACJ,EAAK,eAAe,OAAQ,KAAK,MAAM,GAAG,EAAI,IAKrD,KAAA,MAAQ,YAAY,KAAK,OAAO,KAAK,MAAO,IAAO,IAExD,QAAQ,IAAI,wBAKhB,EAAA,UAAA,MAAA,WAEwB,IAAA,IAAA,EAAA,EAAA,EAAA,KAAK,MAAL,EAAA,EAAA,OAAA,IACG,IADZ,IACY,EAAA,EAAA,EADP,EAAA,GACO,EAAA,EAAA,OAAA,IAAO,CAAX,EAAA,GACN,OAIR,KAAA,QAKT,EAAA,UAAA,IAAA,WAEI,cAAc,KAAK,QAKf,EAAA,UAAA,OAAR,WAEwB,IAAA,IAAA,EAAA,EAAA,EAAA,KAAK,MAAL,EAAA,EAAA,OAAA,IACG,IADZ,IACY,EAAA,EAAA,EADP,EAAA,GACO,EAAA,EAAA,OAAA,IAAO,CAAX,EAAA,GACN,SAIR,KAAA,QAKD,EAAA,UAAA,KAAR,WAES,KAAA,QAAQ,UAAU,EAAG,EAAG,EAAa,GAEtB,IAAA,IAAA,EAAA,EAAA,EAAA,KAAK,MAAL,EAAA,EAAA,OAAA,IACG,IADZ,IACY,EAAA,EAAA,EADP,EAAA,GACO,EAAA,EAAA,OAAA,IAAO,CAAX,EAAA,GACN,KAAK,KAAK,WAOnB,EAAA,UAAA,QAAR,SAAgB,GAEN,IAAA,EAAI,KAAK,OAAO,EAAE,QAAU,KAAK,WAAW,GAAK,EAAA,WACjD,EAAI,KAAK,OAAO,EAAE,QAAU,KAAK,WAAW,GAAK,EAAA,WAClD,KAAA,MAAM,GAAG,GAAG,UAIzB,EAnHA,GAAa,QAAA,UAAA;;ACGT,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAbJ,IAAA,EAAA,QAAA,gBAEA,SAAS,IAEC,IAAA,EAAS,SAAS,eAAe,UACjC,EAAO,IAAI,EAAA,UAAU,GAC3B,EAAK,QAEY,SAAS,eAAe,SAChC,iBAAiB,QAAS,EAAK,MAAM,KAAK,IAIvD","file":"main.9d920f05.js","sourceRoot":"..\\src","sourcesContent":["/** パーツごとの大きさ */\r\nexport const PART_SIZE = 10;\r\n\r\n/** 隣接する要素の方向 */\r\ntype Direction = 'top' | 'right' | 'bottom' | 'left';\r\n\r\n/** 回転の状態 */\r\ntype RotateStatus = 0 | 1 | 2 | 3;\r\n\r\n\r\n/** 個々のパーツクラス */\r\nexport class ChainPart {\r\n\r\n    /** 描画時の傾き */\r\n    private angle: number;\r\n\r\n    /** 回転状態 */\r\n    private rotation: RotateStatus;\r\n\r\n    /** 回転のステップ数 */\r\n    private rotatingCount: number;\r\n\r\n    /** 回転しているかどうかの状態 */\r\n    private _isRotating = false;\r\n\r\n    /** 回転しているかどうかの状態、公開用 */\r\n    get isRotating(): boolean {\r\n        return this._isRotating;\r\n    }\r\n\r\n    /** 隣接するパーツへの参照 */\r\n    private neighbors = new Map<Direction, ChainPart>();\r\n\r\n\r\n    /** 音声コンテキスト */\r\n    static audioCtx: AudioContext;\r\n\r\n    /** 音量調整用のゲインノード */\r\n    static gainNode: GainNode;\r\n\r\n\r\n    constructor(\r\n        private x: number,\r\n        private y: number\r\n    ) {\r\n        this.init();\r\n    }\r\n\r\n\r\n    /** 回転状態の初期化 */\r\n    init(): void {\r\n\r\n        this.rotation = Math.floor(Math.random() * 4) as RotateStatus;\r\n        this.angle = Math.PI / 2 * this.rotation;\r\n        this._isRotating = false;\r\n        this.rotatingCount = 0;\r\n\r\n    }\r\n\r\n    /** 隣接するパーツへの参照を追加 */\r\n    appendNeighbor(direction: Direction, neighbor: ChainPart): void {\r\n\r\n        this.neighbors.set(direction, neighbor);\r\n\r\n    }\r\n\r\n    /** 回転開始 */\r\n    rotate(): void {\r\n\r\n        if (this._isRotating) {\r\n            return;\r\n        }\r\n        this._isRotating = true;\r\n        this.rotatingCount = 0;\r\n        this.playSound();\r\n\r\n    }\r\n\r\n    /** 回転時の効果音を鳴らす */\r\n    private playSound(): void {\r\n\r\n        const osc = new OscillatorNode(ChainPart.audioCtx);\r\n        osc.type = 'sine';\r\n        osc.frequency.value = 300 + this.rotation * 100;\r\n        osc.connect(ChainPart.gainNode);\r\n        osc.start();\r\n        setTimeout(() => osc.stop(), 100);\r\n\r\n    }\r\n\r\n    /** 隣接する要素を回転させる */\r\n    private rotateNeighbors(): void {\r\n\r\n        this.neighbors.forEach((part, direction) => {\r\n            if (\r\n                (\r\n                    direction === 'top' &&\r\n                    (part.rotation === 1 || part.rotation === 2) &&\r\n                    (this.rotation === 0 || this.rotation === 3)\r\n                ) ||\r\n                (\r\n                    direction === 'right' &&\r\n                    (part.rotation === 2 || part.rotation === 3) &&\r\n                    (this.rotation === 0 || this.rotation === 1)\r\n                ) ||\r\n                (\r\n                    direction === 'bottom' &&\r\n                    (part.rotation === 0 || part.rotation === 3) &&\r\n                    (this.rotation === 1 || this.rotation === 2)\r\n                ) ||\r\n                (\r\n                    direction === 'left' &&\r\n                    (part.rotation === 0 || part.rotation === 1) &&\r\n                    (this.rotation === 2 || this.rotation === 3)\r\n                )\r\n            ) {\r\n                part.rotate();\r\n                if (direction === 'top' || direction === 'left') {\r\n                    part.update();\r\n                }\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /** フレーム毎の更新 */\r\n    update(): void {\r\n\r\n        if (this._isRotating) {\r\n            this.angle = (this.angle + Math.PI / 20) % (Math.PI * 2);\r\n            if (++this.rotatingCount == 10) {\r\n                this._isRotating = false;\r\n                this.rotation = (this.rotation + 1) % 4 as RotateStatus;\r\n                this.rotateNeighbors();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /** 画面描画 */\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n\r\n        const harfSize = PART_SIZE / 2;\r\n        ctx.save();\r\n        ctx.fillStyle = '#ddd';\r\n        ctx.strokeStyle = \r\n            this.rotation === 0 ? 'blue' :\r\n            this.rotation === 1 ? 'red' :\r\n            this.rotation === 2 ? 'green' :\r\n            'orange';\r\n        ctx.lineWidth = 2;\r\n        ctx.translate(this.x + harfSize, this.y + harfSize);\r\n        ctx.rotate(this.angle);\r\n        if (this.isRotating) {\r\n            ctx.beginPath();\r\n            ctx.arc(0, 0, harfSize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, -harfSize);\r\n        ctx.lineTo(0, 0);\r\n        ctx.lineTo(harfSize, 0);\r\n        ctx.stroke();\r\n        ctx.restore();\r\n\r\n    }\r\n\r\n}\r\n\r\n/** パーツクラスのスタティックメンバの初期化 */\r\n{\r\n\r\n    ChainPart.audioCtx = new AudioContext();\r\n    ChainPart.gainNode = ChainPart.audioCtx.createGain();\r\n    ChainPart.gainNode.gain.value = 0.01;\r\n    ChainPart.gainNode.connect(ChainPart.audioCtx.destination);\r\n\r\n}\r\n\r\n","import { ChainPart, PART_SIZE } from './chain-part';\r\n\r\n/** 1辺あたりのパーツの数 */\r\nconst PART_COUNT = 50;\r\n\r\n/** キャンバスのサイズ */\r\nconst CANVAS_SIZE = PART_SIZE * PART_COUNT;\r\n\r\n\r\n/** チェインゲームの本体クラス */\r\nexport class ChainGame {\r\n\r\n    /** キャンバスコンテキスト */\r\n    private context: CanvasRenderingContext2D;\r\n\r\n    /** キャンバスの座標情報 */\r\n    private canvasRect: DOMRect;\r\n\r\n    /** パーツ郡への参照 */\r\n    private parts: ChainPart[][];\r\n\r\n    /** タイマーのID */\r\n    private timer: number;\r\n\r\n\r\n    constructor(\r\n        private canvas: HTMLCanvasElement\r\n    ) {\r\n        this.context = canvas.getContext('2d');\r\n        this.canvasRect = canvas.getBoundingClientRect();\r\n    }\r\n\r\n\r\n    /** ゲームの開始 */\r\n    start(): void {\r\n\r\n        this.canvas.width = this.canvas.height = CANVAS_SIZE;\r\n\r\n        this.canvas.addEventListener('mousedown', this.onClick.bind(this));\r\n\r\n        this.parts = Array.from(Array(PART_COUNT), (_, y) =>\r\n            Array.from(Array(PART_COUNT), (_, x) =>\r\n                new ChainPart(x * PART_SIZE, y * PART_SIZE)\r\n            )\r\n        );\r\n\r\n        for (let y = 0; y < PART_COUNT; y++) {\r\n            for (let x = 0; x < PART_COUNT; x++) {\r\n                const part = this.parts[y][x];\r\n                if (y > 0) {\r\n                    part.appendNeighbor('top', this.parts[y - 1][x]);\r\n                }\r\n                if (x < PART_COUNT - 1) {\r\n                    part.appendNeighbor('right', this.parts[y][x + 1]);\r\n                }\r\n                if (y < PART_COUNT - 1) {\r\n                    part.appendNeighbor('bottom', this.parts[y + 1][x]);\r\n                }\r\n                if (x > 0) {\r\n                    part.appendNeighbor('left', this.parts[y][x - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.timer = setInterval(this.update.bind(this), 1000 / 33);\r\n\r\n        console.log('chain game started!');\r\n\r\n    }\r\n\r\n    /** ゲームのリセット */\r\n    reset(): void {\r\n\r\n        for (const parts of this.parts) {\r\n            for (const part of parts) {\r\n                part.init();\r\n            }\r\n        }\r\n\r\n        this.draw();\r\n\r\n    }\r\n\r\n    /** ゲームの終了 */\r\n    end(): void {\r\n\r\n        clearInterval(this.timer);\r\n\r\n    }\r\n\r\n    /** フレーム毎の更新 */\r\n    private update(): void {\r\n\r\n        for (const parts of this.parts) {\r\n            for (const part of parts) {\r\n                part.update();\r\n            }\r\n        }\r\n\r\n        this.draw();\r\n\r\n    }\r\n\r\n    /** 画面描画 */\r\n    private draw(): void {\r\n\r\n        this.context.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);\r\n\r\n        for (const parts of this.parts) {\r\n            for (const part of parts) {\r\n                part.draw(this.context);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /** キャンバスクリック時のイベントハンドラ */\r\n    private onClick(e: MouseEvent): void {\r\n\r\n        const x = Math.floor((e.clientX - this.canvasRect.x) / PART_SIZE);\r\n        const y = Math.floor((e.clientY - this.canvasRect.y) / PART_SIZE);\r\n        this.parts[y][x].rotate();\r\n\r\n    }\r\n\r\n}\r\n","import { ChainGame } from './chain-game';\r\n\r\nfunction main() {\r\n\r\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\r\n    const game = new ChainGame(canvas);\r\n    game.start();\r\n\r\n    const resetBtn = document.getElementById('reset');\r\n    resetBtn.addEventListener('click', game.reset.bind(game));\r\n\r\n}\r\n\r\nmain();\r\n"]}